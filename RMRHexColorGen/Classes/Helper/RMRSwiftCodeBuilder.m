//
//  RMRSwiftCodeBuilder.m
//  RMRHexColorGen
//
//  Created by Stephen O'Connor (MHP) on 20.02.19.
//  Copyright © 2019 RedMadRobot. All rights reserved.
//

#import "RMRSwiftCodeBuilder.h"
#import "RXCollection.h"

// Helper
#import "NSString+RMRHelpers.h"
#import "NSColor+Hexadecimal.h"

// Model
#import "RMRHexColor.h"

#import "Constants.h"


#pragma mark — Constants

static NSString * const kTemplateKeyExtensionClassName            = @"<*category_class_name*>";
static NSString * const kTemplateKeyInputFileName                 = @"<*input_file_name*>";
static NSString * const kTemplateKeyFileName                      = @"<*file_name*>";
static NSString * const kTemplateKeyStaticConstants               = @"<*static_constants*>";
static NSString * const kTemplateKeyEnumName                      = @"<*root_name*>";
static NSString * const kTemplateKeyStaticColornames              = @"<*static_colornames*>";
static NSString * const kTemplateKeyFrameworkName                 = @"<*import_framework_name*>";

static NSString * const kColorExtensionSwiftTemplate =
@"//\n//  <*file_name*>\n//  (This file was autogenerated by RMRHexColorGen, which parsed an input file of: <*input_file_name*>.\n"
@"//  Do not modify as it can easily be overwritten.)\n"
@"\nimport <*import_framework_name*>\n"
@"\nextension <*category_class_name*> {\n"
@"\n<*static_constants*>"
@"}\n";

static NSString * const kNamedColorsEnumSwiftTemplate =
@"//\n//  <*root_name*>.swift\n//  (This file was autogenerated by RMRHexColorGen, which parsed an input file of: <*input_file_name*>.\n"
@"//  Do not modify as it can easily be overwritten.)\n"
@"\nimport <*import_framework_name*>\n"
@"\ninternal enum <*root_name*> {\n"
@"\n<*static_constants*>"
@"\n\n     //--------- Constants used for named colors (you will likely never need them but here for completeness)"
@"\n     internal enum Name {\n"
@"\n<*static_colornames*>"
@"     }\n"
@"}\n";

static NSString * const kValueColorsEnumSwiftTemplate =
@"//\n//  <*root_name*>.swift\n//  (This file was autogenerated by RMRHexColorGen, which parsed an input file of: <*input_file_name*>.\n"
@"//  Do not modify as it can easily be overwritten.)\n"
@"\nimport <*import_framework_name*>\n"
@"\ninternal enum <*root_name*> {\n"
@"\n<*static_constants*>"
@"\n"
@"}\n";

@interface RMRSwiftCodeBuilder ()

#pragma mark — Properties
@property (nonatomic, retain) RMRHexColorGenParameters *parameters;

@property (nonatomic, strong) NSString *colorClassName;
@property (nonatomic, strong) NSString *appFrameworkName;
    
@end


@implementation RMRSwiftCodeBuilder

- (instancetype)initWithParameters:(RMRHexColorGenParameters*)parameters
{
    self = [super init];
    if (self) {
        _parameters = parameters;
        
        _colorClassName = parameters.isForOSX ? @"NSColor" : @"UIColor";
        _appFrameworkName = parameters.isForOSX ? @"AppKit" : @"UIKit";
    }
    return self;
}

- (NSError *)generateSwiftCodeForColors:(NSArray *)colorList
{
    RMRHexColorGenParameters *parameters = self.parameters;
    
    if (parameters.outputFormat == RMRHexColorGenFormatInvalid ||
        parameters.outputFormat == RMRHexColorGenFormatObjectiveCCategory ) {
        return [NSError errorWithDomain:kRMRErrorDomain
                                   code:500
                               userInfo:@{NSLocalizedDescriptionKey: @"You tried building swift code by specifying the wrong parameter for format."}];
    }
    
    NSString *outputName = parameters.name;  // this will be non-nil.  Look where the params are parsed.
    
    NSString *outputFilePath;
    if (parameters.outputFormat == RMRHexColorGenFormatSwiftExtension) {
        NSString *filename = [NSString stringWithFormat:@"%@+%@.swift", _colorClassName, outputName];
        outputFilePath = [[parameters.outputPath stringByExpandingTildeInPath] stringByAppendingPathComponent: filename];
    }
    else if (parameters.outputFormat == RMRHexColorGenFormatSwiftEnum || parameters.outputFormat == RMRHexColorGenFormatAssetCatalog) {
        outputFilePath = [[[parameters.outputPath stringByExpandingTildeInPath] stringByAppendingPathComponent:outputName] stringByAppendingString:@".swift"];
    }
    
    
    // check for existence, remove if so, then create folder
    NSFileManager *fm = [NSFileManager defaultManager];
    BOOL isDir;
    NSError *error = nil;
    
    if([fm fileExistsAtPath:outputFilePath isDirectory:&isDir]) {
        [fm removeItemAtPath:outputFilePath error:&error];
    }
    
    if (error) {
        return error;
    }
    
    if (parameters.outputFormat == RMRHexColorGenFormatSwiftExtension) {
        error = [self buildSwiftExtensionForColors:colorList outputFilePath:outputFilePath];
    }
    else if (parameters.outputFormat == RMRHexColorGenFormatSwiftEnum || parameters.outputFormat == RMRHexColorGenFormatAssetCatalog) {
        error = [self buildSwiftEnumWithNamedColorsUsing:colorList outputFilePath: outputFilePath];
    } else {
        error = [NSError errorWithDomain:kRMRErrorDomain
                                    code:500
                                userInfo:@{NSLocalizedDescriptionKey : @"Something went wrong internally.  You shouldn't see this."}];
    }
    
    return error;
}



#pragma mark - Swift NSColor/UIColor extension

- (NSError*)buildSwiftExtensionForColors:(NSArray *)colorList outputFilePath:(NSString *)outputFilePath
{
    NSString *extensionName = _colorClassName;
    NSString *inputFilename = [self.parameters.inputPath lastPathComponent];
    NSString *filename = [outputFilePath lastPathComponent];
    
    NSString *methods;
    if(self.parameters.useValuesNotNames) {
        methods = [self buildValueBasedColorListWithColorList:colorList];
    } else {
        methods = [self buildNamedColorsListWithColorList:colorList];
    }
    
    
    NSString *swiftFileContent = [[[[[kColorExtensionSwiftTemplate
                                      stringByReplacingOccurrencesOfString:kTemplateKeyFrameworkName withString:_appFrameworkName]
                                     stringByReplacingOccurrencesOfString:kTemplateKeyInputFileName withString:inputFilename]
                                    stringByReplacingOccurrencesOfString:kTemplateKeyExtensionClassName withString:extensionName]
                                   stringByReplacingOccurrencesOfString:kTemplateKeyFileName withString:filename]
                                  stringByReplacingOccurrencesOfString:kTemplateKeyStaticConstants withString:methods];
    
    
    ;
 
    NSError *error = nil;
    [swiftFileContent writeToFile:outputFilePath
                       atomically:YES
                         encoding:NSUTF8StringEncoding
                            error:&error];
    
    return nil;
}

- (NSString *)buildValueBasedColorListWithColorList:(NSArray *)colorList
{
    static NSString * signatureKey = @"<*method_signature*>";
    static NSString * classNameKey = @"<*class_name*>";
    static NSString * redKey       = @"<*red*>";
    static NSString * greenKey     = @"<*green*>";
    static NSString * blueKey      = @"<*blue*>";
    static NSString * alphaKey     = @"<*alpha*>";
    static NSString * commentsKey  = @"<*color_comments*>";
    
    NSString *methodTemplate;
    
    if(self.parameters.isForOSX) {
        // you have more control over color space on OSX.... sRGB is the safest and most likely what the Designers use...
        methodTemplate = @"<*color_comments*>    static let <*method_signature*>: <*class_name*> = <*class_name*>(srgbRed: <*red*>, green: <*green*>, blue: <*blue*>, alpha: <*alpha*>)";
    } else {
        methodTemplate = @"<*color_comments*>    static let <*method_signature*>: <*class_name*> = <*class_name*>(red: <*red*>, green: <*green*>, blue: <*blue*>, alpha: <*alpha*>)";
    }
    
    // the colorList will be sorted first with defined colors, then aliases.
    // so the first alias we encounter, we should generate some more text
    __block BOOL firstColor = YES;
    __block BOOL definedColorsFinished = NO;
    __block BOOL firstReference = NO;
    
    return
    [[colorList rx_mapWithBlock:^id(RMRHexColor *hexColor) {
        
        NSString *sectionComments = nil;
        
        if(firstColor) {
            sectionComments = @"    //-------- Defined Colors with Provided Hex Values\n\n";
            firstColor = NO;
        }
        
        // this works because the assumption is that colorList has been sorted first by non-aliases then aliases.
        if(hexColor.isAlias && !definedColorsFinished) {
            definedColorsFinished = YES;
            firstReference = YES;
        }

        if (firstReference) {
            sectionComments = @"\n\n    //-------- Color Aliases who are references to defined colors above:\n\n";
            firstReference = NO;
        }
        
        NSString *methodSignature = [self buildSwiftMethodSignatureForColor:hexColor];
        
        NSColor *rgbColor = [NSColor colorWithHexString:hexColor.colorValue];
        
        NSString *redComponent   = [@(rgbColor.redComponent) stringValue];
        NSString *greenComponent = [@(rgbColor.greenComponent) stringValue];
        NSString *blueComponent  = [@(rgbColor.blueComponent) stringValue];
        NSString *alphaComponent = [@(rgbColor.alphaComponent) stringValue];
        
        NSString *commentsValue;
        if(hexColor.comments.length > 0) {
            commentsValue = [NSString stringWithFormat:@"     // #%@ - %@\n", hexColor.colorValue, hexColor.comments];
        } else {
            commentsValue = [NSString stringWithFormat:@"     // #%@\n", hexColor.colorValue];
        }
        
        NSString *outputLine =
        [[[[[[[methodTemplate
               stringByReplacingOccurrencesOfString:classNameKey withString:_colorClassName]
              stringByReplacingOccurrencesOfString:signatureKey withString:methodSignature]
             stringByReplacingOccurrencesOfString:redKey       withString:redComponent]
            stringByReplacingOccurrencesOfString:greenKey     withString:greenComponent]
           stringByReplacingOccurrencesOfString:blueKey      withString:blueComponent]
          stringByReplacingOccurrencesOfString:alphaKey     withString:alphaComponent]
         stringByReplacingOccurrencesOfString:commentsKey withString:commentsValue];
        
        if (sectionComments) {
            return [sectionComments stringByAppendingString:outputLine];
        } else {
            return outputLine;
        }
        
    }] rx_foldInitialValue:@"" block:^id(id memo, id each) {
        return [[memo stringByAppendingString:each] stringByAppendingString:@"\n"];
    }];
}

- (NSString *)buildSwiftMethodSignatureForColor:(RMRHexColor *)hexColor
{
    static NSString * prefixKey    = @"<*prefix*>";
    static NSString * colorNameKey = @"<*color_name*>";
    
    static NSString *colorMethodSignatureTemplate =
    @"<*prefix*><*color_name*>";
    
    NSString *prefix = [self.parameters.prefix lowercaseString];
    prefix = prefix ? [prefix stringByAppendingString:@"_"] : @"";
    
    NSString *colorName = [hexColor.colorTitle RMR_lowercaseFirstSymbol];
    
    return
    [[colorMethodSignatureTemplate
      stringByReplacingOccurrencesOfString:prefixKey withString:prefix]
     stringByReplacingOccurrencesOfString:colorNameKey withString:colorName];
}

#pragma mark - Swift Assets Catalog Support

- (NSError*)buildSwiftEnumWithNamedColorsUsing:(NSArray *)colorList outputFilePath:(NSString *)outputFilePath
{
    NSString *inputFilename = [self.parameters.inputPath lastPathComponent];
    NSString *filename = [outputFilePath lastPathComponent];
    NSString *enumname = [filename stringByDeletingPathExtension];
    
    NSString *swiftFileContent;
    
    if(self.parameters.useValuesNotNames) {
        NSString *colorValueConstants = [self buildValueBasedColorListWithColorList:colorList];
        
        swiftFileContent = [[[[kValueColorsEnumSwiftTemplate
                                stringByReplacingOccurrencesOfString:kTemplateKeyFrameworkName withString:_appFrameworkName]
                               stringByReplacingOccurrencesOfString:kTemplateKeyInputFileName withString:inputFilename]
                              stringByReplacingOccurrencesOfString:kTemplateKeyEnumName withString:enumname]
                            stringByReplacingOccurrencesOfString:kTemplateKeyStaticConstants withString:colorValueConstants];
        
    } else {
        NSString *colorStringConstants = [self buildNamedColorConstantsWithColorList:colorList];
        NSString *colorValueConstants = [self buildNamedColorsListWithColorList:colorList];
        
        // first you create an enum called your filename
        swiftFileContent = [[[[[kNamedColorsEnumSwiftTemplate
                                stringByReplacingOccurrencesOfString:kTemplateKeyFrameworkName withString:_appFrameworkName]
                               stringByReplacingOccurrencesOfString:kTemplateKeyInputFileName withString:inputFilename]
                              stringByReplacingOccurrencesOfString:kTemplateKeyEnumName withString:enumname]
                             stringByReplacingOccurrencesOfString:kTemplateKeyStaticColornames withString:colorStringConstants]
                            stringByReplacingOccurrencesOfString:kTemplateKeyStaticConstants withString:colorValueConstants];
    }
    
    
    NSError *error = nil;
    [swiftFileContent writeToFile:outputFilePath
                       atomically:YES
                         encoding:NSUTF8StringEncoding
                            error:&error];
    
    return nil;
}

- (NSString *)buildNamedColorConstantsWithColorList:(NSArray *)colorList
{
    static NSString * signatureKey = @"<*constant_name*>";
    static NSString * valueKey     = @"<*constant_string*>";
    
    static NSString *colorStringTemplate =
    @"          static let <*constant_name*>: String = \"<*constant_string*>\"";
    
    return
    [[colorList rx_mapWithBlock:^id(RMRHexColor *hexColor) {
        NSString *constantValue = hexColor.colorTitle;
        NSString *colorName = [hexColor.colorTitle RMR_lowercaseFirstSymbol];
        
        return
        [[colorStringTemplate
          stringByReplacingOccurrencesOfString:signatureKey withString:colorName]
         stringByReplacingOccurrencesOfString:valueKey       withString:constantValue];
        
    }] rx_foldInitialValue:@"" block:^id(id memo, id each) {
        return [[memo stringByAppendingString:each] stringByAppendingString:@"\n"];
    }];
}

- (NSString *)buildNamedColorsListWithColorList:(NSArray *)colorList
{
    static NSString * classNameKey = @"<*class_name*>";
    static NSString * signatureKey = @"<*color_name*>";
    static NSString * valueKey     = @"<*constant_string*>";
    static NSString * commentsKey     = @"<*color_comments*>";
    
    static NSString *colorStringTemplate =
    @"<*color_comments*>     static let <*color_name*>: <*class_name*> = <*class_name*>(named: \"<*constant_string*>\")!";
    
    // the colorList will be sorted first with defined colors, then aliases.
    // so the first alias we encounter, we should generate some more text
    __block BOOL firstColor = YES;
    __block BOOL definedColorsFinished = NO;
    __block BOOL firstReference = NO;
    
    return
    [[colorList rx_mapWithBlock:^id(RMRHexColor *hexColor) {
        
        NSString *comments = nil;
        
        if(firstColor) {
            comments = @"     //-------- Defined Colors with Provided Hex Values\n\n";
            firstColor = NO;
        }
        
        // this works because the assumption is that colorList has been sorted first by non-aliases then aliases.
        if(hexColor.isAlias && !definedColorsFinished) {
            definedColorsFinished = YES;
            firstReference = YES;
        }
        
        if (firstReference) {
            comments = @"\n\n     //--------- Color Aliases who are references to defined colors above:\n\n";
            firstReference = NO;
        }
    
        NSString *constantValue = hexColor.colorTitle;
        NSString *colorName = [hexColor.colorTitle RMR_lowercaseFirstSymbol];
        
        NSString *commentsValue;
        if(hexColor.comments.length > 0) {
            commentsValue = [NSString stringWithFormat:@"     // #%@ - %@\n", hexColor.colorValue, hexColor.comments];
        } else {
            commentsValue = [NSString stringWithFormat:@"     // #%@\n", hexColor.colorValue];
        }
        
        
        NSString *outputLine =
        [[[[colorStringTemplate
            stringByReplacingOccurrencesOfString:classNameKey withString:_colorClassName]
           stringByReplacingOccurrencesOfString:signatureKey withString:colorName]
          stringByReplacingOccurrencesOfString:valueKey withString:constantValue]
         stringByReplacingOccurrencesOfString:commentsKey withString:commentsValue];
        
        if (comments) {
            return [comments stringByAppendingString:outputLine];
        } else {
            return outputLine;
        }
        
    }] rx_foldInitialValue:@"" block:^id(id memo, id each) {
        return [[memo stringByAppendingString:each] stringByAppendingString:@"\n"];
    }];
}

@end
