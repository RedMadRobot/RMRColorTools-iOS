//
//  RMRSwiftCodeBuilder.m
//  RMRHexColorGen
//
//  Created by Stephen O'Connor (MHP) on 20.02.19.
//  Copyright © 2019 RedMadRobot. All rights reserved.
//

#import "RMRSwiftCodeBuilder.h"
#import "RXCollection.h"

// Helper
#import "NSString+RMRHelpers.h"
#import "NSColor+Hexadecimal.h"

// Model
#import "RMRHexColor.h"

#import "Constants.h"


#pragma mark — Constants

static NSString * const kTemplateKeyExtensionClassName            = @"<*category_class_name*>";
static NSString * const kTemplateKeyFileName                      = @"<*file_name*>";
static NSString * const kTemplateKeyStaticConstants               = @"<*static_constants*>";
static NSString * const kTemplateKeyEnumName                      = @"<*root_name*>";
static NSString * const kTemplateKeyStaticColornames              = @"<*static_colornames*>";


static NSString * const kColorExtensionSwiftTemplate =
@"//\n//  <*file_name*>\n//  (This file was autogenerated by RMRHexColorGen.  Do not modify as it can easily be overwritten.)\n"
@"\nimport UIKit\n"
@"\nextension <*category_class_name*> {\n"
@"\n<*static_constants*>"
@"}\n";

static NSString * const kColorsEnumSwiftTemplate =
@"//\n//  <*root_name*>.swift\n//  (This file was autogenerated by RMRHexColorGen.  Do not modify as it can easily be overwritten.)\n"
@"\nimport UIKit\n"
@"\ninternal enum <*root_name*> {\n"
@"\n     internal enum ColorNames {\n"
@"\n<*static_colornames*>"
@"     }\n\n"
@"\n<*static_constants*>"
@"}\n";

@interface RMRSwiftCodeBuilder ()

#pragma mark — Properties
@property (nonatomic, retain) RMRHexColorGenParameters *parameters;
@property (nonatomic, assign) RMRSwiftOutputType outputType;

@end


@implementation RMRSwiftCodeBuilder

- (instancetype)initWithParameters:(RMRHexColorGenParameters*)parameters outputType:(RMRSwiftOutputType)swiftOutputType
{
    self = [super init];
    if (self) {
        _outputType = swiftOutputType;
        _parameters = parameters;
    }
    return self;
}

- (NSError *)generateSwiftCodeForColors:(NSArray *)colorList
{
    RMRHexColorGenParameters *parameters = self.parameters;
    
    if (parameters.outputFormat == RMRHexColorGenFormatInvalid ||
        parameters.outputFormat == RMRHexColorGenFormatObjectiveC ) {
        return [NSError errorWithDomain:kRMRErrorDomain
                                   code:500
                               userInfo:@{NSLocalizedDescriptionKey: @"You tried building swift code by specifying the wrong parameter for format."}];
    }
    
    NSString *catalogName = parameters.name;  // this will be non-nil.  Look where the params are parsed.
    
    NSString *outputFilePath;
    if (self.outputType == RMRSwiftOutputTypeStandalone) {
        NSString *filename = [NSString stringWithFormat:@"UIColor+%@.swift", catalogName];
        outputFilePath = [[parameters.outputPath stringByExpandingTildeInPath] stringByAppendingPathComponent: filename];
    }
    else if (self.outputType == RMRSwiftOutputTypeAssetsCatalogNamedColors) {
        outputFilePath = [[[parameters.outputPath stringByExpandingTildeInPath] stringByAppendingPathComponent:catalogName] stringByAppendingString:@".swift"];
    }
    
    
    // check for existence, remove if so, then create folder
    NSFileManager *fm = [NSFileManager defaultManager];
    BOOL isDir;
    NSError *error = nil;
    
    if([fm fileExistsAtPath:outputFilePath isDirectory:&isDir]) {
        [fm removeItemAtPath:outputFilePath error:&error];
    }
    
    if (error) {
        return error;
    }
    
    if (self.outputType == RMRSwiftOutputTypeStandalone) {
        error = [self buildSwiftExtensionForColors:colorList outputFilePath:outputFilePath];
    }
    else if (self.outputType == RMRSwiftOutputTypeAssetsCatalogNamedColors) {
        
        error = [self buildSwiftEnumWithNamedColorsUsing:colorList outputFilePath: outputFilePath];
        
    } else {
        error = [NSError errorWithDomain:kRMRErrorDomain
                                    code:500
                                userInfo:@{NSLocalizedDescriptionKey : @"Something went wrong internally.  You shouldn't see this."}];
    }
    
    return error;
}



#pragma mark - Swift UIColor extension

- (NSError*)buildSwiftExtensionForColors:(NSArray *)colorList outputFilePath:(NSString *)outputFilePath
{
    NSString *extensionName = @"UIColor";
    NSString *filename = [outputFilePath lastPathComponent];
    NSString *methods = [self buildMethodGroupForSwiftFileWithColorList:colorList];
    
    NSString *swiftFileContent = [[[kColorExtensionSwiftTemplate
                                    stringByReplacingOccurrencesOfString:kTemplateKeyExtensionClassName withString:extensionName]
                                   stringByReplacingOccurrencesOfString:kTemplateKeyFileName withString:filename]
                                  stringByReplacingOccurrencesOfString:kTemplateKeyStaticConstants withString:methods];
    
    
    ;
 
    NSError *error = nil;
    [swiftFileContent writeToFile:outputFilePath
                       atomically:YES
                         encoding:NSUTF8StringEncoding
                            error:&error];
    
    return nil;
}

- (NSString *)buildMethodGroupForSwiftFileWithColorList:(NSArray *)colorList
{
    static NSString * signatureKey = @"<*method_signature*>";
    static NSString * redKey       = @"<*red*>";
    static NSString * greenKey     = @"<*green*>";
    static NSString * blueKey      = @"<*blue*>";
    static NSString * alphaKey     = @"<*alpha*>";
    
    static NSString *methodTemplate =
    @"    static let <*method_signature*>: UIColor = UIColor(red: <*red*>, green: <*green*>, blue: <*blue*>, alpha: <*alpha*>)";
    
    return
    [[colorList rx_mapWithBlock:^id(RMRHexColor *hexColor) {
        NSString *methodSignature = [self buildSwiftMethodSignatureForColor:hexColor];
        
        NSColor *rgbColor = [NSColor colorWithHexString:hexColor.colorValue];
        
        NSString *redComponent   = [@(rgbColor.redComponent) stringValue];
        NSString *greenComponent = [@(rgbColor.greenComponent) stringValue];
        NSString *blueComponent  = [@(rgbColor.blueComponent) stringValue];
        NSString *alphaComponent = [@(rgbColor.alphaComponent) stringValue];
        
        return
        [[[[[methodTemplate
             stringByReplacingOccurrencesOfString:signatureKey withString:methodSignature]
            stringByReplacingOccurrencesOfString:redKey       withString:redComponent]
           stringByReplacingOccurrencesOfString:greenKey     withString:greenComponent]
          stringByReplacingOccurrencesOfString:blueKey      withString:blueComponent]
         stringByReplacingOccurrencesOfString:alphaKey     withString:alphaComponent];
        
    }] rx_foldInitialValue:@"" block:^id(id memo, id each) {
        return [[memo stringByAppendingString:each] stringByAppendingString:@"\n"];
    }];
}

- (NSString *)buildSwiftMethodSignatureForColor:(RMRHexColor *)hexColor
{
    static NSString * prefixKey    = @"<*prefix*>";
    static NSString * colorNameKey = @"<*color_name*>";
    
    static NSString *colorMethodSignatureTemplate =
    @"<*prefix*><*color_name*>";
    
    NSString *prefix = [self.parameters.prefix lowercaseString];
    prefix = prefix ? [prefix stringByAppendingString:@"_"] : @"";
    
    NSString *colorName = [hexColor.colorTitle RMR_lowercaseFirstSymbol];
    
    return
    [[colorMethodSignatureTemplate
      stringByReplacingOccurrencesOfString:prefixKey withString:prefix]
     stringByReplacingOccurrencesOfString:colorNameKey withString:colorName];
}

#pragma mark - Swift Assets Catalog Support

- (NSError*)buildSwiftEnumWithNamedColorsUsing:(NSArray *)colorList outputFilePath:(NSString *)outputFilePath
{
    NSString *filename = [outputFilePath lastPathComponent];
    NSString *enumname = [filename stringByDeletingPathExtension];
    
    NSString *colorStringConstants = [self buildNamedColorConstantsForSwiftFileWithColorList:colorList];
    NSString *colorValueConstants = [self buildColorsForSwiftFileWithColorList:colorList];
    
    // first you create an enum called your filename
    NSString *swiftFileContent = [[[kColorsEnumSwiftTemplate
                                    stringByReplacingOccurrencesOfString:kTemplateKeyEnumName withString:enumname]
                                   stringByReplacingOccurrencesOfString:kTemplateKeyStaticColornames withString:colorStringConstants]
                                  stringByReplacingOccurrencesOfString:kTemplateKeyStaticConstants withString:colorValueConstants];
    
    NSError *error = nil;
    [swiftFileContent writeToFile:outputFilePath
                       atomically:YES
                         encoding:NSUTF8StringEncoding
                            error:&error];
    
    return nil;
}

- (NSString *)buildNamedColorConstantsForSwiftFileWithColorList:(NSArray *)colorList
{
    static NSString * signatureKey = @"<*constant_name*>";
    static NSString * valueKey     = @"<*constant_string*>";
    
    static NSString *colorStringTemplate =
    @"          static let <*constant_name*>: String = \"<*constant_string*>\"";
    
    return
    [[colorList rx_mapWithBlock:^id(RMRHexColor *hexColor) {
        NSString *constantValue = hexColor.colorTitle;
        NSString *colorName = [hexColor.colorTitle RMR_lowercaseFirstSymbol];
        
        return
        [[colorStringTemplate
          stringByReplacingOccurrencesOfString:signatureKey withString:colorName]
         stringByReplacingOccurrencesOfString:valueKey       withString:constantValue];
        
    }] rx_foldInitialValue:@"" block:^id(id memo, id each) {
        return [[memo stringByAppendingString:each] stringByAppendingString:@"\n"];
    }];
}

- (NSString *)buildColorsForSwiftFileWithColorList:(NSArray *)colorList
{
    static NSString * signatureKey = @"<*color_name*>";
    static NSString * valueKey     = @"<*constant_string*>";
    
    static NSString *colorStringTemplate =
    @"     static let <*color_name*>: UIColor = UIColor(named: \"<*constant_string*>\")!";
    
    return
    [[colorList rx_mapWithBlock:^id(RMRHexColor *hexColor) {
        NSString *constantValue = hexColor.colorTitle;
        NSString *colorName = [hexColor.colorTitle RMR_lowercaseFirstSymbol];
        
        return
        [[colorStringTemplate
          stringByReplacingOccurrencesOfString:signatureKey withString:colorName]
         stringByReplacingOccurrencesOfString:valueKey       withString:constantValue];
        
    }] rx_foldInitialValue:@"" block:^id(id memo, id each) {
        return [[memo stringByAppendingString:each] stringByAppendingString:@"\n"];
    }];
}

@end
